using Dapper;
using Newtonsoft.Json;
using Npgsql;

namespace Tests;

public static class Helper
{
    public static readonly Uri Uri = new Uri(Environment.GetEnvironmentVariable("pgconn")!);

    public static readonly string
        ProperlyFormattedConnectionString = string.Format(
            "Server={0};Database={1};User Id={2};Password={3};Port={4};Pooling=true;MaxPoolSize=3",
            Uri.Host,
            Uri.AbsolutePath.Trim('/'),
            Uri.UserInfo.Split(':')[0],
            Uri.UserInfo.Split(':')[1],
            Uri.Port > 0 ? Uri.Port : 5432);

    public static readonly NpgsqlDataSource DataSource =
        new NpgsqlDataSourceBuilder(ProperlyFormattedConnectionString).Build();

    public static void TriggerRebuild()
    {
        using (var conn = DataSource.OpenConnection())
        {
            conn.Execute(RebuildScript);
        }
    }

    public static string MyBecause(object actual, object expected)
    {
        string expectedJson = JsonConvert.SerializeObject(expected, Formatting.Indented);
        string actualJson = JsonConvert.SerializeObject(actual, Formatting.Indented);

        return $"because we want these objects to be equivalent:\nExpected:\n{expectedJson}\nActual:\n{actualJson}";
    }

    public static string RebuildScript = $@"DROP SCHEMA IF EXISTS library CASCADE;
CREATE SCHEMA library;
create sequence library.booksidseq;

create sequence library.authorsidseq;

create sequence library.useridseq;

create sequence library.booksbookidseq
    as integer;

create sequence library.authorsauthoridseq
    as integer;

create sequence library.endusersenduseridseq
    as integer;

create sequence library.booksbookidseq1
    as integer;

create sequence library.authorsauthoridseq1
    as integer;

create sequence library.endusersenduseridseq1
    as integer;

create table if not exists library.books
(
    bookid       integer generated by default as identity,
    title         text,
    publisher     text,
    coverimgurl text,
    primary key (bookid)
);

alter sequence library.booksidseq owned by library.books.bookid;

create index if not exists booksidtitleindex
    on library.books (bookid, title);

create table if not exists library.authors
(
    authorid   integer generated by default as identity,
    name        text,
    birthday    date,
    nationality text,
    primary key (authorid)
);

alter sequence library.authorsidseq owned by library.authors.authorid;

create index if not exists authorsauthoridnameindex
    on library.authors (authorid, name);

create table if not exists library.authorwrotebookitems
(
    bookid   integer not null,
    authorid integer not null,
    constraint compositekey
        primary key (bookid, authorid),
    constraint fkbook
        foreign key (bookid) references library.books
            on delete cascade,
    constraint fkauthor
        foreign key (authorid) references library.authors
            on delete cascade
);

create table if not exists library.endusers
(
    email           text not null,
    status          text,
    enduserid     integer generated always as identity,
    passwordhash   text not null,
    salt            text not null,
    role            text,
    profileimgurl integer,
    constraint userpk
        primary key (enduserid)
);

alter sequence library.useridseq owned by library.endusers.enduserid;

create table if not exists library.readinglistitems
(
    userid integer not null,
    bookid integer not null,
    constraint readinglistitemspk
        primary key (bookid, userid),
    constraint readinglistitemsuseridfk
        foreign key (userid) references library.endusers
            on delete cascade,
    constraint readinglistitemsbooksidfk
        foreign key (bookid) references library.books
            on delete cascade
); ";
}